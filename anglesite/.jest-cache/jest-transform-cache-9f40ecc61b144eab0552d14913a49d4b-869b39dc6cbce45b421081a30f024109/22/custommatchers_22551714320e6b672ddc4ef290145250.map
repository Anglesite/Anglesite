{"file":"/Users/dwk/Developer/gitlab.com/davidwkeith/@dwk/anglesite/test/matchers/custom-matchers.ts","mappings":"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","names":[],"sources":["/Users/dwk/Developer/gitlab.com/davidwkeith/@dwk/anglesite/test/matchers/custom-matchers.ts"],"sourcesContent":["/**\n * @file Custom Jest matchers for Anglesite tests\n *\n * These matchers reduce repetitive assertion patterns across the test suite\n * and provide more descriptive error messages for common test scenarios.\n */\n\nimport type { MockCall, WindowMock, WindowState, InputHandler } from '../types/matcher-types';\nimport { INVALID_INPUTS as invalidInputs, isString, isFunction } from '../types/matcher-types';\n\ndeclare global {\n  namespace jest {\n    interface Matchers<R> {\n      /**\n       * Assert that a function creates a window successfully without throwing\n       */\n      toCreateWindowSuccessfully(): R;\n\n      /**\n       * Assert that a mock Electron event was emitted synchronously\n       */\n      toEmitEventSynchronously(eventName: string): R;\n\n      /**\n       * Assert that a function executes without throwing\n       */\n      toExecuteWithoutError(): R;\n\n      /**\n       * Assert that a mock was called with a path containing the expected string\n       */\n      toBeCalledWithPath(expectedPath: string): R;\n\n      /**\n       * Assert that a window mock has specific state\n       */\n      toHaveWindowState(state: WindowState): R;\n\n      /**\n       * Assert that IPC handler was registered for a channel\n       */\n      toHandleIpcChannel(channel: string): R;\n\n      /**\n       * Assert that a mock returned a successful promise\n       */\n      toResolveSuccessfully(): R;\n\n      /**\n       * Assert that a function handles missing/invalid input gracefully\n       */\n      toHandleInvalidInputGracefully(): R;\n    }\n  }\n}\n\n/**\n * Custom matcher: toCreateWindowSuccessfully.\n * Verifies that a function creates a window without throwing and returns a defined result.\n */\nexpect.extend({\n  toCreateWindowSuccessfully(received: () => unknown) {\n    let result: unknown;\n    let error: Error | undefined;\n\n    try {\n      result = received();\n    } catch (e) {\n      error = e as Error;\n    }\n\n    const pass = !error && result !== undefined && result !== null;\n\n    return {\n      pass,\n      message: () => {\n        if (error) {\n          return `Expected function to create window successfully, but it threw: ${error.message}`;\n        }\n        if (result === undefined || result === null) {\n          return `Expected function to create window successfully, but it returned ${result}`;\n        }\n        return `Expected function not to create window successfully`;\n      },\n    };\n  },\n\n  /**\n   * Custom matcher: toEmitEventSynchronously.\n   * Verifies that a mock function triggers an event handler synchronously.\n   */\n  toEmitEventSynchronously(received: jest.Mock, eventName: string) {\n    const mockCalls = received.mock.calls as MockCall[];\n    const eventHandler = mockCalls.find((call) => call[0] === eventName);\n\n    const pass = eventHandler !== undefined && isFunction(eventHandler[1]);\n\n    return {\n      pass,\n      message: () => {\n        if (!eventHandler) {\n          return `Expected to emit \"${eventName}\" event, but no handler was registered`;\n        }\n        if (typeof eventHandler[1] !== 'function') {\n          return `Expected to emit \"${eventName}\" event with a function handler, but got ${typeof eventHandler[1]}`;\n        }\n        return `Expected not to emit \"${eventName}\" event synchronously`;\n      },\n    };\n  },\n\n  /**\n   * Custom matcher: toExecuteWithoutError.\n   * Verifies that a function executes without throwing.\n   */\n  toExecuteWithoutError(received: () => unknown) {\n    let error: Error | undefined;\n\n    try {\n      received();\n    } catch (e) {\n      error = e as Error;\n    }\n\n    const pass = !error;\n\n    return {\n      pass,\n      message: () => {\n        if (error) {\n          return `Expected function to execute without error, but it threw: ${error.message}`;\n        }\n        return `Expected function to throw an error`;\n      },\n    };\n  },\n\n  /**\n   * Custom matcher: toBeCalledWithPath.\n   * Verifies that a mock was called with a path containing the expected string.\n   */\n  toBeCalledWithPath(received: jest.Mock, expectedPath: string) {\n    const calls = received.mock.calls as MockCall[];\n    const pathCall = calls.find((call) => call.some((arg) => isString(arg) && arg.includes(expectedPath)));\n\n    const pass = pathCall !== undefined;\n\n    return {\n      pass,\n      message: () => {\n        if (!pathCall) {\n          const actualPaths = calls\n            .flat()\n            .filter((arg) => isString(arg) && arg.includes('/'))\n            .join(', ');\n          return `Expected to be called with path containing \"${expectedPath}\"${actualPaths ? `, but was called with: ${actualPaths}` : ', but no paths were found'}`;\n        }\n        return `Expected not to be called with path containing \"${expectedPath}\"`;\n      },\n    };\n  },\n\n  /**\n   * Custom matcher: toHaveWindowState.\n   * Verifies that a window mock has specific state properties.\n   */\n  toHaveWindowState(received: WindowMock, expectedState: WindowState) {\n    const actualState: WindowState = {};\n    let mismatches: string[] = [];\n\n    if (expectedState.destroyed !== undefined) {\n      actualState.destroyed = received.isDestroyed?.() ?? false;\n      if (actualState.destroyed !== expectedState.destroyed) {\n        mismatches.push(`destroyed: expected ${expectedState.destroyed}, got ${actualState.destroyed}`);\n      }\n    }\n\n    if (expectedState.maximized !== undefined) {\n      actualState.maximized = received.isMaximized?.() ?? false;\n      if (actualState.maximized !== expectedState.maximized) {\n        mismatches.push(`maximized: expected ${expectedState.maximized}, got ${actualState.maximized}`);\n      }\n    }\n\n    if (expectedState.focused !== undefined) {\n      actualState.focused = received.isFocused?.() ?? false;\n      if (actualState.focused !== expectedState.focused) {\n        mismatches.push(`focused: expected ${expectedState.focused}, got ${actualState.focused}`);\n      }\n    }\n\n    if (expectedState.title !== undefined) {\n      actualState.title = received.getTitle?.() ?? '';\n      if (actualState.title !== expectedState.title) {\n        mismatches.push(`title: expected \"${expectedState.title}\", got \"${actualState.title}\"`);\n      }\n    }\n\n    const pass = mismatches.length === 0;\n\n    return {\n      pass,\n      message: () => {\n        if (mismatches.length > 0) {\n          return `Expected window to have state:\\n${mismatches.join('\\n')}`;\n        }\n        return `Expected window not to have state: ${JSON.stringify(expectedState)}`;\n      },\n    };\n  },\n\n  /**\n   * Custom matcher: toHandleIpcChannel.\n   * Verifies that an IPC handler was registered for a specific channel.\n   */\n  toHandleIpcChannel(received: jest.Mock, channel: string) {\n    const calls = received.mock.calls as MockCall[];\n    const channelHandler = calls.find((call) => call[0] === channel);\n\n    const pass = channelHandler !== undefined;\n\n    return {\n      pass,\n      message: () => {\n        if (!channelHandler) {\n          const registeredChannels = calls\n            .map((call) => call[0])\n            .filter(Boolean)\n            .join(', ');\n          return `Expected to handle IPC channel \"${channel}\"${registeredChannels ? `, but only handles: ${registeredChannels}` : ', but no channels are handled'}`;\n        }\n        return `Expected not to handle IPC channel \"${channel}\"`;\n      },\n    };\n  },\n\n  /**\n   * Custom matcher: toResolveSuccessfully.\n   * Verifies that a promise resolves without rejection.\n   */\n  async toResolveSuccessfully(received: Promise<unknown>) {\n    let resolved = false;\n    let rejected = false;\n    let error: Error | undefined;\n\n    try {\n      await received;\n      resolved = true;\n    } catch (e) {\n      rejected = true;\n      error = e as Error;\n    }\n\n    const pass = resolved && !rejected;\n\n    return {\n      pass,\n      message: () => {\n        if (rejected) {\n          return `Expected promise to resolve successfully, but it rejected with: ${error?.message}`;\n        }\n        return `Expected promise to reject`;\n      },\n    };\n  },\n\n  /**\n   * Custom matcher: toHandleInvalidInputGracefully.\n   * Verifies that a function handles various invalid inputs without throwing.\n   */\n  toHandleInvalidInputGracefully(received: InputHandler) {\n    const failures: Array<{ input: unknown; error: Error }> = [];\n\n    for (const input of invalidInputs) {\n      try {\n        received(input);\n      } catch (e) {\n        failures.push({ input, error: e as Error });\n      }\n    }\n\n    const pass = failures.length === 0;\n\n    return {\n      pass,\n      message: () => {\n        if (failures.length > 0) {\n          const failureMessages = failures\n            .map((f) => `  Input ${JSON.stringify(f.input)}: ${f.error.message}`)\n            .join('\\n');\n          return `Expected function to handle invalid inputs gracefully, but it threw for:\\n${failureMessages}`;\n        }\n        return `Expected function to throw for invalid inputs`;\n      },\n    };\n  },\n});\n\nexport {}; // Ensure this is a module\n"],"version":3}